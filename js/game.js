// Generated by CoffeeScript 1.3.3
(function() {
  var Board, Cell, Scoreboard;

  Board = (function() {
    var COLORS;

    COLORS = ["circle-red", "circle-green", "circle-blue", "circle-yellow"];

    function Board(scoreboard, w, h, newCirclesNum, lineLength) {
      var addCell, cell, i, j, rowElement, _i, _j, _ref, _ref1;
      this.scoreboard = scoreboard;
      this.w = w != null ? w : 6;
      this.h = h != null ? h : 6;
      this.newCirclesNum = newCirclesNum != null ? newCirclesNum : 3;
      this.lineLength = lineLength != null ? lineLength : 4;
      addCell = function(rowElement, cell) {
        var cellElement,
          _this = this;
        cellElement = cell.getElement();
        cellElement.addEventListener("click", function(event) {
          return _this.selectCell(cell);
        });
        rowElement.appendChild(cellElement);
        this.cells[i].push(cell);
        return this.emptyCells.push(cell);
      };
      this.enabled = true;
      this.cells = [];
      this.emptyCells = [];
      this.element = document.createElement("tbody");
      for (i = _i = 0, _ref = this.h - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.cells.push([]);
        rowElement = document.createElement("tr");
        this.element.appendChild(rowElement);
        for (j = _j = 0, _ref1 = this.w - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          cell = new Cell(this, i, j);
          addCell.call(this, rowElement, cell);
        }
      }
      this.addNewCircles();
    }

    Board.prototype.getElement = function() {
      return this.element;
    };

    Board.prototype.addNewCircles = function() {
      var i, randomCell, randomCellIndex, randomColor, randomColorIndex;
      i = 0;
      while (i++ < this.newCirclesNum) {
        randomCellIndex = Math.floor(Math.random() * this.emptyCells.length);
        randomCell = this.emptyCells[randomCellIndex];
        this.emptyCells.splice(randomCellIndex, 1);
        randomColorIndex = Math.floor(Math.random() * COLORS.length);
        randomColor = COLORS[randomColorIndex];
        randomCell.show(randomColor, true);
      }
      return this.removeLines();
    };

    Board.prototype.removeLines = function() {
      var cell, i, j, k, _i, _j, _k, _len, _ref, _ref1, _ref2;
      this.cellsToClean = [];
      for (i = _i = 0, _ref = this.h - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.w - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          if (i < this.h - this.lineLength + 1) {
            this.testLine((function() {
              var _k, _ref2, _results;
              _results = [];
              for (k = _k = 0, _ref2 = this.lineLength - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                _results.push(this.cells[i + k][j]);
              }
              return _results;
            }).call(this));
          }
          if (j < this.w - this.lineLength + 1) {
            this.testLine((function() {
              var _k, _ref2, _results;
              _results = [];
              for (k = _k = 0, _ref2 = this.lineLength - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                _results.push(this.cells[i][j + k]);
              }
              return _results;
            }).call(this));
          }
          if (i < this.h - this.lineLength + 1 && j < this.w - this.lineLength + 1) {
            this.testLine((function() {
              var _k, _ref2, _results;
              _results = [];
              for (k = _k = 0, _ref2 = this.lineLength - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                _results.push(this.cells[i + k][j + k]);
              }
              return _results;
            }).call(this));
          }
          if (i < this.h - this.lineLength + 1 && j >= this.lineLength - 1) {
            this.testLine((function() {
              var _k, _ref2, _results;
              _results = [];
              for (k = _k = 0, _ref2 = this.lineLength - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                _results.push(this.cells[i + k][j - k]);
              }
              return _results;
            }).call(this));
          }
        }
      }
      _ref2 = this.cellsToClean;
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        cell = _ref2[_k];
        this.cleanCell(cell);
      }
      return this.scoreboard.increaseScore(this.cellsToClean.length);
    };

    Board.prototype.testLine = function(line) {
      var cell, removeLine;
      removeLine = line.every(function(cell, index) {
        return index === line.length - 1 || cell.color && cell.color === line[index + 1].color;
      });
      if (removeLine) {
        return this.cellsToClean = this.cellsToClean.concat((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = line.length; _i < _len; _i++) {
            cell = line[_i];
            if (this.cellsToClean.indexOf(cell) === -1) {
              _results.push(cell);
            }
          }
          return _results;
        }).call(this));
      }
    };

    Board.prototype.cleanCell = function(cell) {
      cell.hide(true);
      return this.emptyCells.push(cell);
    };

    Board.prototype.selectCell = function(cell) {
      var path;
      if (this.enabled && this.selectedCell && !cell.color) {
        path = this.findPath(this.selectedCell.column, this.selectedCell.row, cell.column, cell.row);
        if (path.length > 0) {
          this.moveCell(this.selectedCell, path);
          this.selectedCell = null;
        }
      }
      if (cell.color) {
        if (this.selectedCell) {
          this.selectedCell.deselect();
        }
        this.selectedCell = cell;
        return this.selectedCell.select();
      }
    };

    Board.prototype.moveCell = function(movableCell, path) {
      var _this = this;
      this.movableCell = movableCell;
      this.path = path;
      this.enabled = false;
      this.step = 0;
      this.emptyCells.push(this.movableCell);
      return this.moveInterval = setInterval(function() {
        return _this.makeNextCellMove();
      }, 100);
    };

    Board.prototype.makeNextCellMove = function() {
      var cellIndex, movableCellColor, stepData;
      movableCellColor = this.movableCell.color;
      this.movableCell.hide();
      stepData = this.path[this.step];
      this.movableCell = this.cells[stepData.row][stepData.column];
      this.movableCell.show(movableCellColor);
      this.step++;
      if (this.step === this.path.length) {
        clearInterval(this.moveInterval);
        cellIndex = this.emptyCells.indexOf(this.movableCell);
        this.emptyCells.splice(cellIndex, 1);
        this.removeLines();
        if (this.cellsToClean.length === 0 || this.emptyCells.length === this.w * this.h) {
          this.addNewCircles();
        }
        return this.enabled = true;
      }
    };

    Board.prototype.getQueueHashKey = function(column, row) {
      return "" + column + "." + row;
    };

    Board.prototype.findPath = function(column1, row1, column2, row2) {
      this.targetColumn = column1;
      this.targetRow = row1;
      this.queue = [];
      this.queueHash = {};
      this.stepsToTarget = Number.MAX_VALUE;
      this.inspectCell(column2, row2);
      return this.queue.reverse();
    };

    Board.prototype.inspectCell = function(currentColumn, currentRow, queue, step) {
      var cell, queueHashKey, stepData;
      if (queue == null) {
        queue = [];
      }
      if (step == null) {
        step = 0;
      }
      if (currentColumn === this.targetColumn && currentRow === this.targetRow) {
        this.stepsToTarget = step;
        this.queue = queue;
      }
      if (!((this.w > currentColumn && currentColumn >= 0))) {
        return;
      }
      if (!((this.h > currentRow && currentRow >= 0))) {
        return;
      }
      queueHashKey = this.getQueueHashKey(currentColumn, currentRow);
      if (this.queueHash[queueHashKey] <= step) {
        return;
      }
      cell = this.cells[currentRow][currentColumn];
      if (cell.color) {
        return;
      }
      stepData = {
        column: currentColumn,
        row: currentRow,
        step: step
      };
      queue = queue.concat(stepData);
      this.queueHash[queueHashKey] = step;
      if (step < this.stepsToTarget) {
        step++;
        this.inspectCell(currentColumn - 1, currentRow, queue, step);
        this.inspectCell(currentColumn + 1, currentRow, queue, step);
        this.inspectCell(currentColumn, currentRow - 1, queue, step);
        return this.inspectCell(currentColumn, currentRow + 1, queue, step);
      }
    };

    return Board;

  })();

  Cell = (function() {

    function Cell(board, row, column) {
      this.board = board;
      this.row = row;
      this.column = column;
      this.element = document.createElement("td");
      this.image = document.createElement("div");
      this.element.appendChild(this.image);
    }

    Cell.prototype.getElement = function() {
      return this.element;
    };

    Cell.prototype.show = function(color, animate) {
      var onAnimationEnd,
        _this = this;
      this.color = color;
      if (animate == null) {
        animate = false;
      }
      this.image.className += " " + this.color;
      onAnimationEnd = function(e) {
        _this.image.className = _this.image.className.replace(/\bcircle-fade-in\b/, "");
        return _this.image.removeEventListener(e.type, onAnimationEnd);
      };
      if (animate) {
        this.image.addEventListener("webkitAnimationEnd", onAnimationEnd);
        this.image.addEventListener("animationend", onAnimationEnd);
        return this.image.className += " circle-fade-in";
      }
    };

    Cell.prototype.hide = function(animate) {
      var onAnimationEnd,
        _this = this;
      if (animate == null) {
        animate = false;
      }
      onAnimationEnd = function(e) {
        if (e) {
          _this.image.removeEventListener(e.type, onAnimationEnd);
        }
        _this.image.className = "";
        return _this.color = null;
      };
      if (animate) {
        this.image.addEventListener("webkitAnimationEnd", onAnimationEnd);
        this.image.addEventListener("animationend", onAnimationEnd);
        return this.image.className += " circle-fade-out";
      } else {
        return onAnimationEnd();
      }
    };

    Cell.prototype.select = function() {
      return this.image.className += " circle-jump";
    };

    Cell.prototype.deselect = function() {
      return this.image.className = this.image.className.replace(/\bcircle-jump\b/, "");
    };

    return Cell;

  })();

  window.onload = function() {
    var board, scoreboard;
    scoreboard = new Scoreboard;
    document.getElementById("scoreboard").appendChild(scoreboard.getElement());
    board = new Board(scoreboard);
    return document.getElementById("board").appendChild(board.getElement());
  };

  Scoreboard = (function() {

    function Scoreboard() {
      this.element = document.createElement("p");
      this.resetScore();
    }

    Scoreboard.prototype.getElement = function() {
      return this.element;
    };

    Scoreboard.prototype.resetScore = function() {
      this.score = 0;
      return this.updateScore();
    };

    Scoreboard.prototype.increaseScore = function(numCircles) {
      if (numCircles >= 4) {
        this.score += 10 + (numCircles - 4) * 20;
      }
      return this.updateScore();
    };

    Scoreboard.prototype.updateScore = function() {
      if (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      return this.element.appendChild(document.createTextNode(this.score.toString()));
    };

    return Scoreboard;

  })();

}).call(this);
